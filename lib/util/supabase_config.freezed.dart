// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'supabase_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SupabaseConfig _$SupabaseConfigFromJson(Map<String, dynamic> json) {
  return _SupabaseConfig.fromJson(json);
}

/// @nodoc
mixin _$SupabaseConfig {
  String get anonKey => throw _privateConstructorUsedError;
  String get apiUrl => throw _privateConstructorUsedError;
  String? get dbUrl => throw _privateConstructorUsedError;
  String? get graphqlUrl => throw _privateConstructorUsedError;
  String? get inbucketUrl => throw _privateConstructorUsedError;
  String? get jwtSecret => throw _privateConstructorUsedError;
  String? get serviceRoleKey => throw _privateConstructorUsedError;
  String? get studioUrl => throw _privateConstructorUsedError;

  /// Serializes this SupabaseConfig to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SupabaseConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SupabaseConfigCopyWith<SupabaseConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SupabaseConfigCopyWith<$Res> {
  factory $SupabaseConfigCopyWith(
          SupabaseConfig value, $Res Function(SupabaseConfig) then) =
      _$SupabaseConfigCopyWithImpl<$Res, SupabaseConfig>;
  @useResult
  $Res call(
      {String anonKey,
      String apiUrl,
      String? dbUrl,
      String? graphqlUrl,
      String? inbucketUrl,
      String? jwtSecret,
      String? serviceRoleKey,
      String? studioUrl});
}

/// @nodoc
class _$SupabaseConfigCopyWithImpl<$Res, $Val extends SupabaseConfig>
    implements $SupabaseConfigCopyWith<$Res> {
  _$SupabaseConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SupabaseConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? anonKey = null,
    Object? apiUrl = null,
    Object? dbUrl = freezed,
    Object? graphqlUrl = freezed,
    Object? inbucketUrl = freezed,
    Object? jwtSecret = freezed,
    Object? serviceRoleKey = freezed,
    Object? studioUrl = freezed,
  }) {
    return _then(_value.copyWith(
      anonKey: null == anonKey
          ? _value.anonKey
          : anonKey // ignore: cast_nullable_to_non_nullable
              as String,
      apiUrl: null == apiUrl
          ? _value.apiUrl
          : apiUrl // ignore: cast_nullable_to_non_nullable
              as String,
      dbUrl: freezed == dbUrl
          ? _value.dbUrl
          : dbUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      graphqlUrl: freezed == graphqlUrl
          ? _value.graphqlUrl
          : graphqlUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      inbucketUrl: freezed == inbucketUrl
          ? _value.inbucketUrl
          : inbucketUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      jwtSecret: freezed == jwtSecret
          ? _value.jwtSecret
          : jwtSecret // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceRoleKey: freezed == serviceRoleKey
          ? _value.serviceRoleKey
          : serviceRoleKey // ignore: cast_nullable_to_non_nullable
              as String?,
      studioUrl: freezed == studioUrl
          ? _value.studioUrl
          : studioUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SupabaseConfigImplCopyWith<$Res>
    implements $SupabaseConfigCopyWith<$Res> {
  factory _$$SupabaseConfigImplCopyWith(_$SupabaseConfigImpl value,
          $Res Function(_$SupabaseConfigImpl) then) =
      __$$SupabaseConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String anonKey,
      String apiUrl,
      String? dbUrl,
      String? graphqlUrl,
      String? inbucketUrl,
      String? jwtSecret,
      String? serviceRoleKey,
      String? studioUrl});
}

/// @nodoc
class __$$SupabaseConfigImplCopyWithImpl<$Res>
    extends _$SupabaseConfigCopyWithImpl<$Res, _$SupabaseConfigImpl>
    implements _$$SupabaseConfigImplCopyWith<$Res> {
  __$$SupabaseConfigImplCopyWithImpl(
      _$SupabaseConfigImpl _value, $Res Function(_$SupabaseConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of SupabaseConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? anonKey = null,
    Object? apiUrl = null,
    Object? dbUrl = freezed,
    Object? graphqlUrl = freezed,
    Object? inbucketUrl = freezed,
    Object? jwtSecret = freezed,
    Object? serviceRoleKey = freezed,
    Object? studioUrl = freezed,
  }) {
    return _then(_$SupabaseConfigImpl(
      anonKey: null == anonKey
          ? _value.anonKey
          : anonKey // ignore: cast_nullable_to_non_nullable
              as String,
      apiUrl: null == apiUrl
          ? _value.apiUrl
          : apiUrl // ignore: cast_nullable_to_non_nullable
              as String,
      dbUrl: freezed == dbUrl
          ? _value.dbUrl
          : dbUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      graphqlUrl: freezed == graphqlUrl
          ? _value.graphqlUrl
          : graphqlUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      inbucketUrl: freezed == inbucketUrl
          ? _value.inbucketUrl
          : inbucketUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      jwtSecret: freezed == jwtSecret
          ? _value.jwtSecret
          : jwtSecret // ignore: cast_nullable_to_non_nullable
              as String?,
      serviceRoleKey: freezed == serviceRoleKey
          ? _value.serviceRoleKey
          : serviceRoleKey // ignore: cast_nullable_to_non_nullable
              as String?,
      studioUrl: freezed == studioUrl
          ? _value.studioUrl
          : studioUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.screamingSnake)
class _$SupabaseConfigImpl
    with DiagnosticableTreeMixin
    implements _SupabaseConfig {
  const _$SupabaseConfigImpl(
      {required this.anonKey,
      required this.apiUrl,
      this.dbUrl,
      this.graphqlUrl,
      this.inbucketUrl,
      this.jwtSecret,
      this.serviceRoleKey,
      this.studioUrl});

  factory _$SupabaseConfigImpl.fromJson(Map<String, dynamic> json) =>
      _$$SupabaseConfigImplFromJson(json);

  @override
  final String anonKey;
  @override
  final String apiUrl;
  @override
  final String? dbUrl;
  @override
  final String? graphqlUrl;
  @override
  final String? inbucketUrl;
  @override
  final String? jwtSecret;
  @override
  final String? serviceRoleKey;
  @override
  final String? studioUrl;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SupabaseConfig(anonKey: $anonKey, apiUrl: $apiUrl, dbUrl: $dbUrl, graphqlUrl: $graphqlUrl, inbucketUrl: $inbucketUrl, jwtSecret: $jwtSecret, serviceRoleKey: $serviceRoleKey, studioUrl: $studioUrl)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SupabaseConfig'))
      ..add(DiagnosticsProperty('anonKey', anonKey))
      ..add(DiagnosticsProperty('apiUrl', apiUrl))
      ..add(DiagnosticsProperty('dbUrl', dbUrl))
      ..add(DiagnosticsProperty('graphqlUrl', graphqlUrl))
      ..add(DiagnosticsProperty('inbucketUrl', inbucketUrl))
      ..add(DiagnosticsProperty('jwtSecret', jwtSecret))
      ..add(DiagnosticsProperty('serviceRoleKey', serviceRoleKey))
      ..add(DiagnosticsProperty('studioUrl', studioUrl));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SupabaseConfigImpl &&
            (identical(other.anonKey, anonKey) || other.anonKey == anonKey) &&
            (identical(other.apiUrl, apiUrl) || other.apiUrl == apiUrl) &&
            (identical(other.dbUrl, dbUrl) || other.dbUrl == dbUrl) &&
            (identical(other.graphqlUrl, graphqlUrl) ||
                other.graphqlUrl == graphqlUrl) &&
            (identical(other.inbucketUrl, inbucketUrl) ||
                other.inbucketUrl == inbucketUrl) &&
            (identical(other.jwtSecret, jwtSecret) ||
                other.jwtSecret == jwtSecret) &&
            (identical(other.serviceRoleKey, serviceRoleKey) ||
                other.serviceRoleKey == serviceRoleKey) &&
            (identical(other.studioUrl, studioUrl) ||
                other.studioUrl == studioUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, anonKey, apiUrl, dbUrl,
      graphqlUrl, inbucketUrl, jwtSecret, serviceRoleKey, studioUrl);

  /// Create a copy of SupabaseConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SupabaseConfigImplCopyWith<_$SupabaseConfigImpl> get copyWith =>
      __$$SupabaseConfigImplCopyWithImpl<_$SupabaseConfigImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SupabaseConfigImplToJson(
      this,
    );
  }
}

abstract class _SupabaseConfig implements SupabaseConfig {
  const factory _SupabaseConfig(
      {required final String anonKey,
      required final String apiUrl,
      final String? dbUrl,
      final String? graphqlUrl,
      final String? inbucketUrl,
      final String? jwtSecret,
      final String? serviceRoleKey,
      final String? studioUrl}) = _$SupabaseConfigImpl;

  factory _SupabaseConfig.fromJson(Map<String, dynamic> json) =
      _$SupabaseConfigImpl.fromJson;

  @override
  String get anonKey;
  @override
  String get apiUrl;
  @override
  String? get dbUrl;
  @override
  String? get graphqlUrl;
  @override
  String? get inbucketUrl;
  @override
  String? get jwtSecret;
  @override
  String? get serviceRoleKey;
  @override
  String? get studioUrl;

  /// Create a copy of SupabaseConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SupabaseConfigImplCopyWith<_$SupabaseConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
